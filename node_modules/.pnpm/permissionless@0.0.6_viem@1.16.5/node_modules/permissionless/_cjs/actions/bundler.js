"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundlerActions = exports.getUserOperationReceipt = exports.getUserOperationByHash = exports.chainId = exports.supportedEntryPoints = exports.estimateUserOperationGas = exports.sendUserOperation = void 0;
const utils_1 = require("./utils");
const sendUserOperation = async (client, args) => {
    const { userOperation, entryPoint } = args;
    return client.request({
        method: "eth_sendUserOperation",
        params: [(0, utils_1.deepHexlify)(userOperation), entryPoint]
    });
};
exports.sendUserOperation = sendUserOperation;
const estimateUserOperationGas = async (client, args) => {
    const { userOperation, entryPoint } = args;
    const response = await client.request({
        method: "eth_estimateUserOperationGas",
        params: [(0, utils_1.deepHexlify)(userOperation), entryPoint]
    });
    return {
        preVerificationGas: BigInt(response.preVerificationGas || 0n),
        verificationGasLimit: BigInt(response.verificationGasLimit || 0n),
        callGasLimit: BigInt(response.callGasLimit || 0n)
    };
};
exports.estimateUserOperationGas = estimateUserOperationGas;
const supportedEntryPoints = async (client) => {
    return client.request({
        method: "eth_supportedEntryPoints",
        params: []
    });
};
exports.supportedEntryPoints = supportedEntryPoints;
const chainId = async (client) => {
    return Number(await client.request({
        method: "eth_chainId",
        params: []
    }));
};
exports.chainId = chainId;
const getUserOperationByHash = async (client, { hash }) => {
    const params = [hash];
    const response = await client.request({
        method: "eth_getUserOperationByHash",
        params
    });
    if (!response)
        return null;
    const { userOperation, entryPoint, transactionHash, blockHash, blockNumber } = response;
    return {
        userOperation: {
            ...userOperation,
            nonce: BigInt(userOperation.nonce),
            callGasLimit: BigInt(userOperation.callGasLimit),
            verificationGasLimit: BigInt(userOperation.verificationGasLimit),
            preVerificationGas: BigInt(userOperation.preVerificationGas),
            maxFeePerGas: BigInt(userOperation.maxFeePerGas),
            maxPriorityFeePerGas: BigInt(userOperation.maxPriorityFeePerGas)
        },
        entryPoint: entryPoint,
        transactionHash: transactionHash,
        blockHash: blockHash,
        blockNumber: BigInt(blockNumber)
    };
};
exports.getUserOperationByHash = getUserOperationByHash;
const getUserOperationReceipt = async (client, { hash }) => {
    const params = [hash];
    const response = await client.request({
        method: "eth_getUserOperationReceipt",
        params
    });
    if (!response)
        return null;
    const userOperationReceipt = {
        userOpHash: response.userOpHash,
        sender: response.sender,
        nonce: BigInt(response.nonce),
        actualGasUsed: BigInt(response.actualGasUsed),
        actualGasCost: BigInt(response.actualGasCost),
        success: response.success,
        receipt: {
            transactionHash: response.receipt.transactionHash,
            transactionIndex: BigInt(response.receipt.transactionIndex),
            blockHash: response.receipt.blockHash,
            blockNumber: BigInt(response.receipt.blockNumber),
            from: response.receipt.from,
            to: response.receipt.to,
            cumulativeGasUsed: BigInt(response.receipt.cumulativeGasUsed),
            status: utils_1.transactionReceiptStatus[response.receipt.status],
            gasUsed: BigInt(response.receipt.gasUsed),
            contractAddress: response.receipt.contractAddress,
            logsBloom: response.receipt.logsBloom,
            effectiveGasPrice: BigInt(response.receipt.effectiveGasPrice)
        },
        logs: response.logs.map((log) => ({
            data: log.data,
            blockNumber: BigInt(log.blockNumber),
            blockHash: log.blockHash,
            transactionHash: log.transactionHash,
            logIndex: BigInt(log.logIndex),
            transactionIndex: BigInt(log.transactionIndex),
            address: log.address,
            topics: log.topics
        }))
    };
    return userOperationReceipt;
};
exports.getUserOperationReceipt = getUserOperationReceipt;
const bundlerActions = (client) => ({
    sendUserOperation: async (args) => (0, exports.sendUserOperation)(client, args),
    estimateUserOperationGas: (args) => (0, exports.estimateUserOperationGas)(client, args),
    supportedEntryPoints: () => (0, exports.supportedEntryPoints)(client),
    chainId: () => (0, exports.chainId)(client),
    getUserOperationByHash: (args) => (0, exports.getUserOperationByHash)(client, args),
    getUserOperationReceipt: (args) => (0, exports.getUserOperationReceipt)(client, args)
});
exports.bundlerActions = bundlerActions;
//# sourceMappingURL=bundler.js.map